/**
 * SPiFI_test_driver.jenkinsfile
 *
 * Test the SPiFI library
 */
properties([
    buildDiscarder(logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '',
                              daysToKeepStr: '365',       numToKeepStr: '90')),
    disableConcurrentBuilds(),
    pipelineTriggers([ cron('H 0 * * *')]),
    parameters([
        booleanParam(name: 'CleanWorkspace', defaultValue: false,
                     description: '''Optionally clean the workspace before entering the pipeline.'''),
        string(name: 'EMAIL_REPLYTO', defaultValue: 'wcmclen@sandia.gov', description: ''),
        string(name: 'EMAIL_DEVOPS', defaultValue: 'wcmclen@sandia.gov', description: ''),
    ])
])

// ,pollSCM('H/15 7-20 * * *')   // -- POLLING SCM isn't working b/c Jenkins compares the branch against master so it runs every !!@#! time



// import groovy.transform.Field


String email_body       = "<H1>SPiFI Test Summary</H1>\n"
List   exit_status_list = ["SUCCESS", "FAILURE", "UNSTABLE", "ABORTED", "NOT_BUILT"]



node()
{
    String emailDevOps  = "wcmclen@sandia.gov"
    String emailReplyTo = "wcmclen@sandia.gov"
    String branchName   = "master"

    if(params.containsKey("EMAIL_REPLYTO"))
    {
        emailReplyTo = params.EMAIL_REPLYTO
    }
    if(params.containsKey("EMAIL_DEVOPS"))
    {
        emailDevOps = params.EMAIL_DEVOPS
    }

    // Global faiulre counter for use at the end of testing.
    Integer num_failures = 0;


    // ----[ begin stage: Clean Workspace ]------------------------------------
    stage('Clean Workspace')
    {
        boolean doCleanWorkspace = false
        println "\u27A4\n" +
                "\u27A4 Stage: Clean Workspace\n" +
                "\u27A4"
        if(params.containsKey("CleanWorkspace"))
        {
            if(params.CleanWorkspace)
            {
                doCleanWorkspace = true
            }
        }
        if(doCleanWorkspace)
        {
            cleanWs();
            println "\u27A4 Workspace cleaned."
        }
        else
        {
            println "\u27A4 Workspace NOT cleaned."
        }
    }
    // ----[ end stage: Clean Workspace ]--------------------------------------


    timeout(time: 60, unit: "MINUTES")
    {



        // Stage 1: Launch SPiFI_test_selectable_status job to make sure it works.
        stage("1) Test Job Simulator Script")
        {
            boolean stage_passed = true

            email_body += """
                          <H3>Stage (1): Test Job Simulator Script</H3>
                          <ol>
                          """.stripIndent()

            exit_status_list.each
            {   _desired_exit_status ->

                println ">>> TEST: SPiFI_test_selectable_status [${_desired_exit_status}]"

                status = build job        : "SPiFI_test_selectable_status",
                               quietPeriod: 0,
                               propagate  : false,
                               parameters : [ (string(name:"SLEEP_TIME",  value: "1")),
                                              (string(name:"EXIT_STATUS", value: "${_desired_exit_status}"))
                                            ]

                if(status.getResult() != "${_desired_exit_status}")
                {
                    println ">>> ERROR: SPiFI_test_selectable_status job gave incorrect result.\n" +
                            ">>>        Expected: ${_desired_exit_status} but got ${status.getResult()}"

                    email_body += "<li>FAILED: SPiFI_test_selectable_status( ${_desired_exit_status} )</li>\n"
                    stage_passed = false
                }
                else
                {
                    email_body += "<li>PASSED: SPiFI_test_selectable_status( ${_desired_exit_status} )</li>\n"
                }
            }
            email_body += "</ol>\n"

            // Test desired result: SUCCESS
            if(!stage_passed)
            {
                sendEmailFailureAndQuit(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }

        } // end stage (1)



        // Stage 2: Try to load SPiFI
        stage("2) Test Load SPiFI Library")
        {
            boolean stage_passed = true

            email_body += "<H3>Stage (2): Test Load SPiFI Library</H3>\n"

            try
            {
                //@Field final String LIBRARY_VERSION = "SPiFI@${BRANCH_NAME}"
                //println "LIBRARY_VERSION: ${LIBRARY_VERSION}"
                //@Library(LIBRARY_VERSION) _       // Note: even this is b0rked in Jenkins... you have to use a literal constant.

                @Library('SPiFI@master') _     // Note: this must be const string, can't parameterize :/
                branchName = "master"

                email_body += "<ol><li>PASSED: Load SPiFI Library (branch: refactor)</li></ol>\n"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<ol><li>FAILED: Load SPiFI Library (branch: refactor)</li></ol>\n"
                stage_passed = false
            }

            if(!stage_passed)
            {
                sendEmailFailureAndQuit(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }

        }



        // Stage 3: Parallel Job Launcher (dry-run mode jobs)
        stage("3) Test Parallel Job Launcher (dry-run mode)")
        {
            boolean stage_passed = true

            def launcher = new gov.sandia.sems.spifi.ParallelJobLauncher(this)

            exit_status_list.each
            {   _exit_status ->

                println ">>> LAUNCHER: APPEND(T-${_exit_status}-DRYRUN)"

                launcher.appendJob(label: "T-${_exit_status}-DRYRUN",
                                   job_name: "SPiFI_test_selectable_status",
                                   timeout: 90,
                                   timeout_unit: "SECONDS",
                                   parameters: [ (string(name:"EXIT_STATUS",  value: "${_exit_status}")),
                                                 (string(name:"SLEEP_TIME", value: "1"))
                                               ],
                                    dry_run: true,
                                    dry_run_status: "${_exit_status}",
                                    dry_run_delay: 1
                                  )
            }

            // Print out the list of jobs.
            try
            {
                launcher.printJobList()
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                println ">>> ERROR: launcher.printJobList failed"
                sendEmailFailureAndQuit(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }

            // Launch the jobs in parallel
            def results = null
            try
            {
                results = launcher.launchInParallel()
                println(">>> results: ${results}")

                email_body += "<H3>Stage (3): Test Parallel Job Launcher (dry-run mode)</H3>\n"
                email_body += "<ol>\n"
                exit_status_list.each
                {   _exit_status ->

                    String test_name = "T-${_exit_status}-DRYRUN"

                    if(results["${test_name}"].status == "${_exit_status}")
                    {
                       email_body += "<li>PASSED: ${test_name}</li>\n"
                    }
                    else
                    {
                       stage_passed = false
                       email_body += "<li>FAILED: ${test_name}</li>\n"
                    }
                }
                email_body += "</ol>\n"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                println ">>> ERROR: launcher.launchInParallel failed"
                sendEmailFailureAndQuit(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }

            // Check result summary
            try
            {
                def summary = launcher.getLastResultSummary()
                println ">>> SUMMARY: ${summary}"

                email_body += "<H4>Launcher Summary</H4>\n"
                email_body += "<ol>\n"
                if(summary.NUMJOBS == 5)
                {
                    email_body += "<li>PASSED: NUMJOBS == 5</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMJOBS != 5 (got ${summary.NUMJOBS})</li>\n"
                    stage_passed = false
                }

                if(summary.NUMSUCCESS == 1)
                {
                    email_body += "<li>PASSED: NUMSUCCESS == 1</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMSUCCESS != 1 (got ${summary.NUMSUCCESS})</li>\n"
                    stage_passed = false
                }

                if(summary.NUMFAILURE == 1)
                {
                    email_body += "<li>PASSED: NUMFAILURE == 1</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMFAILURE != 1 (got ${summary.NUMFAILURE})</li>\n"
                    stage_passed = false
                }

                if(summary.NUMUNSTABLE == 1)
                {
                    email_body += "<li>PASSED: NUMUNSTABLE == 1</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMUNSTABLE != 1 (got ${summary.NUMUNSTABLE})</li>\n"
                    stage_passed = false
                }

                if(summary.NUMABORTED == 1)
                {
                    email_body += "<li>PASSED: NUMABORTED == 1</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMABORTED != 1 (got ${summary.NUMABORTED})</li>\n"
                    stage_passed = false
                }

                if(summary.NUMNOT_BUILT == 1)
                {
                    email_body += "<li>PASSED: NUMNOT_BUILT == 1</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMNOT_BUILT != 1 (got ${summary.NUMNOT_BUILT})</li>\n"
                    stage_passed = false
                }
                email_body += "</ol>\n"
            }
            catch(ex)
            {
                println ">>> ERROR: parallelJobLauncher -- check last result summary failed"
                sendEmailFailureAndQuit(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }

            /*
            if(!stage_passed)
            {
                sendEmailFailureAndQuit(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }
            */

        }   // end stage 3



        // Create 2 vars to carry over to the email builder stage if stage 4 passes.
        def launcher_results = null
        def launcher_summary = null



        // Stage 4: Parallel Job Launcher (real-run mode jobs)
        stage("4) Test Parallel Job Launcher (real-run mode)")
        {
            boolean stage_passed = true

            def launcher = new gov.sandia.sems.spifi.ParallelJobLauncher(this)

            // Add one job of each type to the list
            exit_status_list.each
            {   _exit_status ->

                println ">>> LAUNCHER: APPEND(T-${_exit_status}-RUN)"

                launcher.appendJob(label: "T-${_exit_status}-RUN",
                                   job_name: "SPiFI_test_selectable_status",
                                   timeout: 90,
                                   timeout_unit: "SECONDS",
                                   parameters: [ (string(name:"EXIT_STATUS",  value: "${_exit_status}")),
                                                 (string(name:"SLEEP_TIME", value: "1"))
                                               ]
                                  )
            }

            // Add jobs that test expected_duration_min and expected_duration_max bounds
            // Both should have their status reset to UNSTABLE
            launcher.appendJob(label: "T-EXPECTED-DURATION-MIN-RUN",
                                job_name: "SPiFI_test_selectable_status",
                                timeout: 90,
                                timeout_unit: "SECONDS",
                                expected_duration_min: 1,
                                expected_duration_units: "MINUTES",
                                parameters: [ (string(name:"EXIT_STATUS",  value: "SUCCESS")),
                                              (string(name:"SLEEP_TIME", value: "12"))
                                            ]
                                )

            launcher.appendJob(label: "T-EXPECTED-DURATION-MAX-RUN",
                                job_name: "SPiFI_test_selectable_status",
                                timeout: 90,
                                timeout_unit: "SECONDS",
                                expected_duration_max: 8,
                                expected_duration_units: "SECONDS",
                                parameters: [ (string(name:"EXIT_STATUS",  value: "SUCCESS")),
                                              (string(name:"SLEEP_TIME", value: "12"))
                                            ]
                                )

            // Print out the list of jobs.
            try
            {
                launcher.printJobList()
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                println ">>> ERROR: parallelJobLauncher -- printJobList failed"
                sendEmailFailureAndQuit(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }

            // Launch the jobs in parallel
            try
            {
                launcher_results = launcher.launchInParallel()

                println(">>> results: ${launcher_results}")

                email_body += "<H3>Stage (4): Test Parallel Job Launcher (real-run mode)</H3>\n"

                email_body += "<ol>\n"
                exit_status_list.each
                {   _exit_status ->

                    String test_name = "T-${_exit_status}-RUN"

                    if(launcher_results["${test_name}"].status == "${_exit_status}")
                    {
                       email_body += "<li>PASSED: ${test_name}</li>\n"
                    }
                    else
                    {
                       stage_passed = false
                       email_body += "<li>FAILED: ${test_name}</li>\n"
                    }
                }
                email_body += "</ol>\n"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                println ">>> ERROR: parallelJobLauncher -- launchInParallel failed"
                sendEmailFailureAndQuit(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }

            // Check result summary
            try
            {
                launcher_summary = launcher.getLastResultSummary()
                println ">>> SUMMARY: ${launcher_summary}"

                email_body += "<H4>Launcher Summary</H4>\n"
                email_body += "<ol>\n"
                if(launcher_summary.NUMJOBS == 7)
                {
                    email_body += "<li>PASSED: NUMJOBS == 7</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMJOBS != 7 (got ${launcher_summary.NUMJOBS})</li>\n"
                    stage_passed = false
                }

                if(launcher_summary.NUMSUCCESS == 1)
                {
                    email_body += "<li>PASSED: NUMSUCCESS == 1</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMSUCCESS != 1 (got ${launcher_summary.NUMSUCCESS})</li>\n"
                    stage_passed = false
                }

                if(launcher_summary.NUMFAILURE == 1)
                {
                    email_body += "<li>PASSED: NUMFAILURE == 1</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMFAILURE != 1 (got ${launcher_summary.NUMFAILURE})</li>\n"
                    stage_passed = false
                }

                if(launcher_summary.NUMUNSTABLE == 3)
                {
                    email_body += "<li>PASSED: NUMUNSTABLE == 3</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMUNSTABLE != 3 (got ${launcher_summary.NUMUNSTABLE})</li>\n"
                    stage_passed = false
                }

                if(launcher_summary.NUMABORTED == 1)
                {
                    email_body += "<li>PASSED: NUMABORTED == 1</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMABORTED != 1 (got ${launcher_summary.NUMABORTED})</li>\n"
                    stage_passed = false
                }

                if(launcher_summary.NUMNOT_BUILT == 1)
                {
                    email_body += "<li>PASSED: NUMNOT_BUILT == 1</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMNOT_BUILT != 1 (got ${launcher_summary.NUMNOT_BUILT})</li>\n"
                    stage_passed = false
                }
                email_body += "</ol>\n"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                println ">>> ERROR: parallelJobLauncher -- check last result summary failed"
                sendEmailFailureAndQuit(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }

            /*
            if(!stage_passed)
            {
                sendEmailFailureAndQuit(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }
            */

        }   // End Stage 4


        // Stage 5: ResultsUtility
        stage("5) Test ResultsUtility")
        {
            boolean stage_passed = true

            println launcher_summary
            println launcher_results

            email_body += "<H3>Stage 5) Test Results Utility</H3>\n"

            email_body += "<ul>\n"

            def result_util = null
            try
            {
                result_util = new gov.sandia.sems.spifi.ResultsUtility(env: this)
                email_body += "<li>PASSED: Instantiate</li>\n"
            }
            catch(ex)
            {
                email_body += "<li>FAILED: Instantiate</li>\n"
                println ">>> ERROR:\n${ex}"
                num_failures++
            }

            // Test Summary Table Generation (ASCII)
            println ">>> Test Summary Table Generation (ASCII)"
            try{
                def output = result_util.genResultSummaryTable(summary: launcher_summary, format: "ASCII")
                email_body += "<li>PASSED: genResultSummaryTable (ASCII)</li>\n"
                println ">>> summary table ascii:\n${output}"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<li>FAILED: genResultSummaryTable (ASCII)</li>\n"
                num_failures++
            }

            // Test Summary Table Generation (Markdown)
            println ">>> Test Summary Table Generation (MARKDOWN)"
            try{
                def output = result_util.genResultSummaryTable(summary: launcher_summary, format: "MARKDOWN")
                email_body += "<li>PASSED: genResultSummaryTable (MARKDOWN)</li>\n"
                println ">>> summary table Markdown:\n${output}"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<li>FAILED: genResultSummaryTable (MARKDOWN)</li>\n"
                num_failures++
            }

            // Test Summary Table Generation (HTML)
            println ">>> Test Summary Table Generation (HTML)"
            try{
                def output = result_util.genResultSummaryTable(summary: launcher_summary, format: "HTML")
                email_body += "<li>PASSED: genResultSummaryTable (HTML)</li>\n"
                println ">>> summary table HTML:\n${output}"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<li>FAILED: genResultSummaryTable (HTML)</li>\n"
                num_failures++
            }

            // Test Detail Table Generation (ASCII)
            println ">>> Test Detail Table Generation (ASCII)"
            try{
                def output = result_util.genResultDetailTable(results: launcher_results, format: "ASCII")
                email_body += "<li>PASSED: genResultDetailTable (ASCII)</li>\n"
                println ">>> details table ascii:\n${output}"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<li>FAILED: genResultDetailTable (ASCII)</li>\n"
                num_failures++
            }

            // Test Detail Table Generation (MARKDOWN)
            println ">>> Test Detail Table Generation (MARKDOWN)"
            try{
                def output = result_util.genResultDetailTable(results: launcher_results, format: "MARKDOWN")
                email_body += "<li>PASSED: genResultDetailTable (MARKDOWN)</li>\n"
                println ">>> details table ascii:\n${output}"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<li>FAILED: genResultDetailTable (MARKDOWN)</li>\n"
                num_failures++
            }

            // Test Detail Table Generation (HTML)
            println ">>> Test Detail Table Generation (HTML)"
            try{
                def output = result_util.genResultDetailTable(results: launcher_results, format: "HTML")
                email_body += "<li>PASSED: genResultDetailTable (HTML)</li>\n"
                println ">>> details table ascii:\n${output}"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<li>FAILED: genResultDetailTable (HTML)</li>\n"
                num_failures++
            }

            email_body += "</ul>\n"
        }  // End Stage 5



        // Stage 6: Test org.sandia.sems.spifi.Shell
        stage("6) Shell")
        {
            boolean stage_passed = true

            email_body += "<H3>Stage (6): Test Shell</H3>\n"

            email_body += "<ul>\n"

            try
            {
                def shell = new gov.sandia.sems.spifi.Shell()
                def output = shell.execute(env: this, command: "ls -l -tr", verbose: true)
                println "Shell Output:\n" +
                        "- retries: ${output.retries}\n" +
                        "- status : ${output.status}\n" +
                        "- stdout: ${output.stdout}\n"
                email_body += "<li>PASSED: Shell.execute()</li>\n"
            }
            catch(e)
            {
                email_body += "<li>FAILED: Shell.execute() threw an exception</li>\n"
                println "ERROR occurred in Shell():\n${e}"
            }

            try
            {
                def shell = new gov.sandia.sems.spifi.Shell()
                def output = shell.execute(env: this,
                                           command: "ls /aksfosuayfoausydfoy123123123",
                                           retries: 2,
                                           retry_delay: 2,
                                           verbose: true)
                println "Shell Output:\n" +
                        "- retries: ${output.retries}\n" +
                        "- status : ${output.status}\n"  +
                        "- stdout:\n${output.stdout}\n"
                if(output.status == 2 && output.retries == 2)
                {
                    email_body += "<li>PASSED: Shell.execute() nonzero status retry failure</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: Shell.execute() nonzero status retry failure</li>\n"
                }
            }
            catch(e)
            {
                email_body += "<li>FAILED: Shell.execute() threw an exception</li>\n"
                println "ERROR occurred in Shell():\n${e}"
            }

            try
            {
                def shell = new gov.sandia.sems.spifi.Shell()
                def output = shell.execute(env: this,
                                           command: "ls /aksfosuayfoausydfoy123123123",
                                           retries: 2,
                                           retry_delay: 2,
                                           status_values_ok: [2],
                                           verbose: true)
                println "Shell Output:\n" +
                        "- retries: ${output.retries}\n" +
                        "- status : ${output.status}\n"  +
                        "- stdout:\n${output.stdout}\n"
                if(output.status == 2 && output.retries==0)
                {
                    email_body += "<li>PASSED: Shell.execute() nonzero status whitelisted</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: Shell.execute() nonzero status whitelisted</li>\n"
                }
            }
            catch(e)
            {
                email_body += "<li>FAILED: Shell.execute() threw an exception</li>\n"
                println "ERROR occurred in Shell():\n${e}"
            }

            email_body += "</ul>\n"

        } // End Stage 6



        // Stage 7: Test org.sandia.sems.spifi.Git
        stage("7) Git")
        {
            boolean stage_passed = true

            email_body += "<H3>Stage (7): Test Git</H3>\n"
            email_body += "<ul>\n"
            try
            {

                def git_spifi = new gov.sandia.sems.spifi.Git()


                git_spifi.clone(env: this,
                                dir: "SPiFI",
                                url: "git@gitlab-ex.sandia.gov:wcmclen/sems-pipeline-framework-infrastructure.git",
                                credentialsId: "0aacc0f3-7e90-4b0f-9eda-068f1d6ce052",
                                retries: 2,
                                retry_delay: 10,
                                timeout: 90,
                                timeout_units: "SECONDS",
                                verbose: true
                               )

                def stdout = sh(script: "ls -ltr SPiFI/", returnStdout: true)
                println "STDOUT:\n${stdout}"

                email_body += "<li>PASSED: Git.clone() cloned a repository</li>\n"
            }
            catch(e)
            {
                email_body += "<li>FAILED: Git.clone() threw an exception</li>\n"
                println "ERROR: Git.clone() threw an exception:\n${e}"
                stage_passed = false
                currentBuild.result='FAILURE'
            }

            email_body += "</ul>\n"

        } // End Stage 7



        // Stage 8: Summary (is that even necessary?)
        stage("8) Email Summary")
        {
            println ">>> Send email summary"

            // Final test is to try and send email using SPiFI EmailMessage class
            // if it fails then send the usual email.
            try
            {
                mail to:       emailDevOps,
                     replyTo:  emailReplyTo,
                     mimeType: "text/html",
                     subject:  "[SPiFI] Testing Summary PASSED for ${branchName}",
                     body:     email_body
            }
            catch(e)
            {
                println ">>> ERROR:${e}"
                email_body += "<H3>Stage (8): Email Summary</H3>\n"
                sendEmailFailureAndQuit(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }
        }   // End Stage 8

    }   // timeout
}   // node



//def sendEmailFailureAndQuit(String email_body)
def sendEmailFailureAndQuit(Map params)
{
    email_body = "<H1>FAILURE ENCOUNTERED!</H1>\n" + params.body
    sendEmailSummary(to:       params.to,
                     reply_to: params.reply_to,
                     subject:  "[SPiFI] Testing Summary FAILED for ${branchName}",
                     body:     email_body)
    currentBuild.result='FAILURE'
}



def sendEmailSummary(Map params)
{
    String email_message = """
                           <HTML>
                           <HEAD>
                           </HEAD>
                           <BODY>
                           {{MESSAGE_BODY}}
                           </BODY>
                           </HTML>
                           """.stripIndent()

    String __email_message = email_message.replace("{{MESSAGE_BODY}}", params.body)

    mail to:       params.to,
         replyTo:  params.reply_to,
         mimeType: 'text/html',
         subject:  params.subject,
         body:     __email_message
    }

