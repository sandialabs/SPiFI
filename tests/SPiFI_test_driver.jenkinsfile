#!/usr/bin/env groovy
/**
 * SPiFI_test_driver.jenkinsfile
 *
 * Test the SPiFI library
 */

// Configure default node restrictions
String node_restriction = "RHEL7 || RHEL6 || master"



properties([
    buildDiscarder(logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '',
                              daysToKeepStr: '365',       numToKeepStr: '90')),
    disableConcurrentBuilds(),
    pipelineTriggers([ cron('H 0 * * *') ]),
    parameters([
        booleanParam(name: 'CleanWorkspace', defaultValue: false,
                     description: '''Optionally clean the workspace before entering the pipeline.'''),
        string(defaultValue: node_restriction,
               description: "Node restriction, default: '${node_restriction}'",
               name: 'NODE_RESTRICTION'),
        string(name: 'EMAIL_REPLYTO', defaultValue: 'wcmclen@sandia.gov', description: ''),
        string(name: 'EMAIL_DEVOPS', defaultValue: 'wcmclen@sandia.gov dmvigi@sandia.gov bmpersc@sandia.gov', description: ''),
    ])
])
// pipeline trigger with SCM Polling (old)
// pipelineTriggers([ cron('H 0 * * *'), pollSCM('H/15 7-20 * * *') ]),



// Get the Jenkins host we're running on (jenkins-srn-dev, jenkins-srn, etc.)
String jenkins_site = env.JOB_URL.tokenize('/')[1].split("\\.")[0]

// What is the branch name that we want to use
String branchName = "master"


// Load node restriction(s) from parameters
if(params.containsKey("NODE_RESTRICTION"))
{
  node_restriction = params.NODE_RESTRICTION
}

// Misc global vars.
String email_body = ""
List   exit_status_list = ["SUCCESS", "FAILURE", "UNSTABLE", "ABORTED", "NOT_BUILT"]



node(node_restriction)
{
    String emailDevOps  = "wcmclen@sandia.gov"
    String emailReplyTo = "wcmclen@sandia.gov"

    if(params.containsKey("EMAIL_REPLYTO"))
    {
        emailReplyTo = params.EMAIL_REPLYTO
    }
    if(params.containsKey("EMAIL_DEVOPS"))
    {
        emailDevOps = params.EMAIL_DEVOPS
    }

    // Global faiulre counter for use at the end of testing.
    Integer num_failures = 0
    Integer num_tests    = 0


    // ----[ begin stage: Clean Workspace ]------------------------------------
    stage('Clean Workspace')
    {
        boolean doCleanWorkspace = false
        println "\u27A4\n" +
                "\u27A4 Stage: Clean Workspace\n" +
                "\u27A4"
        if(params.containsKey("CleanWorkspace"))
        {
            if(params.CleanWorkspace)
            {
                doCleanWorkspace = true
            }
        }
        if(doCleanWorkspace)
        {
            cleanWs();
            println "\u27A4 Workspace cleaned."
        }
        else
        {
            println "\u27A4 Workspace NOT cleaned."
        }
    }
    // ----[ end stage: Clean Workspace ]--------------------------------------


    timeout(time: 60, unit: "MINUTES")
    {



        // Stage 1: Launch SPiFI_test_selectable_status job to make sure it works.
        stage("1) Test Job Simulator Script")
        {
            boolean stage_passed = true

            email_body += """
                          <H3>Stage (1): Test Job Simulator Script</H3>
                          <ol>
                          """.stripIndent()

            exit_status_list.each
            {   _desired_exit_status ->

                println ">>> TEST: SPiFI_test_selectable_status [${_desired_exit_status}]"

                status = build job        : "SPiFI_test_selectable_status",
                               quietPeriod: 0,
                               propagate  : false,
                               parameters : [ (string(name:"SLEEP_TIME",  value: "1")),
                                              (string(name:"EXIT_STATUS", value: "${_desired_exit_status}"))
                                            ]

                if(status.getResult() != "${_desired_exit_status}")
                {
                    println ">>> ERROR: SPiFI_test_selectable_status job gave incorrect result.\n" +
                            ">>>        Expected: ${_desired_exit_status} but got ${status.getResult()}"

                    email_body += "<li>FAILED: SPiFI_test_selectable_status( ${_desired_exit_status} )</li>\n"
                    stage_passed = false
                }
                else
                {
                    email_body += "<li>PASSED: SPiFI_test_selectable_status( ${_desired_exit_status} )</li>\n"
                }
            }
            email_body += "</ol>\n"

            // Test desired result: SUCCESS
            if(!stage_passed)
            {
                sendEmailFailure(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }

        } // end stage (1)



        // Stage 2: Try to load SPiFI
        stage("2) Test Load SPiFI Library")
        {
            boolean stage_passed = true

            email_body += "<H3>Stage (2): Test Load SPiFI Library</H3>\n"

            try
            {
                //@Field final String LIBRARY_VERSION = "SPiFI@${BRANCH_NAME}"
                //println "LIBRARY_VERSION: ${LIBRARY_VERSION}"
                //@Library(LIBRARY_VERSION) _       // Note: even this is b0rked in Jenkins... you have to use a literal constant.

                @Library('SPiFI-DEV@master') _     // Note: this must be const string, can't parameterize :/
                // @Library('SPiFI') _             // Default version for production

                email_body += "<ol>\n"
                email_body += "  <li>PASSED: Load SPiFI Library (SPiFI-DEV@master)</li>\n"

                // Update branchName with spifi.Info.version() if possible
                try
                {
                    branchName = gov.sandia.sems.spifi.Info.version()
                    email_body += "  <li>PASSED: Version Loaded: ${branchName}</li>\n"
                    println ">>> Branch Loaded Version Info OK: ${branchName}"
                }
                catch(ex)
                {
                    println "An error occurred loading gov.sandia.sems.spifi.Info.version()\n${ex}"
                    email_body += "  <li>FAILED: Version Loaded: ${branchName}</li>\n"
                    println ">>> Branch Loaded Version Info FAILED: ${branchName}"
                }
                email_body += "</ol>\n"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<ol><li>FAILED: Load SPiFI Library (SPiFI-DEV@master)</li></ol>\n"
                stage_passed = false
            }

            if(!stage_passed)
            {
                sendEmailFailure(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }

        }



        // Stage 3: Parallel Job Launcher (dry-run mode jobs)
        stage("3) Test Parallel Job Launcher (dry-run mode)")
        {
            boolean stage_passed = true

            def launcher = new gov.sandia.sems.spifi.ParallelJobLauncher(this)

            exit_status_list.each
            {   _exit_status ->

                println ">>> LAUNCHER: APPEND(T-${_exit_status}-DRYRUN)"

                launcher.appendJob(label: "T-${_exit_status}-DRYRUN",
                                   job_name: "SPiFI_test_selectable_status",
                                   timeout: 90,
                                   timeout_unit: "SECONDS",
                                   parameters: [ (string(name:"EXIT_STATUS",  value: "${_exit_status}")),
                                                 (string(name:"SLEEP_TIME", value: "1"))
                                               ],
                                    dry_run: true,
                                    dry_run_status: "${_exit_status}",
                                    dry_run_delay: 1
                                  )
            }

            // Print out the list of jobs.
            try
            {
                launcher.printJobList()
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                println ">>> ERROR: launcher.printJobList failed"
                sendEmailFailure(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }

            // Launch the jobs in parallel
            def results = null
            try
            {
                results = launcher.launchInParallel()
                println(">>> results: ${results}")

                email_body += "<H3>Stage (3): Test Parallel Job Launcher (dry-run mode)</H3>\n"
                email_body += "<ol>\n"
                exit_status_list.each
                {   _exit_status ->

                    String test_name = "T-${_exit_status}-DRYRUN"

                    if(results["${test_name}"].status == "${_exit_status}")
                    {
                       email_body += "<li>PASSED: ${test_name}</li>\n"
                    }
                    else
                    {
                       stage_passed = false
                       email_body += "<li>FAILED: ${test_name}</li>\n"
                    }
                }
                email_body += "</ol>\n"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                println ">>> ERROR: launcher.launchInParallel failed"
                sendEmailFailure(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }

            // Check result summary
            try
            {
                def summary = launcher.getLastResultSummary()
                println ">>> SUMMARY: ${summary}"

                email_body += "<H4>Launcher Summary</H4>\n"
                email_body += "<ol>\n"
                if(summary.NUMJOBS == 5)
                {
                    email_body += "<li>PASSED: NUMJOBS == 5</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMJOBS != 5 (got ${summary.NUMJOBS})</li>\n"
                    stage_passed = false
                }

                if(summary.NUMSUCCESS == 1)
                {
                    email_body += "<li>PASSED: NUMSUCCESS == 1</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMSUCCESS != 1 (got ${summary.NUMSUCCESS})</li>\n"
                    stage_passed = false
                }

                if(summary.NUMFAILURE == 1)
                {
                    email_body += "<li>PASSED: NUMFAILURE == 1</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMFAILURE != 1 (got ${summary.NUMFAILURE})</li>\n"
                    stage_passed = false
                }

                if(summary.NUMUNSTABLE == 1)
                {
                    email_body += "<li>PASSED: NUMUNSTABLE == 1</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMUNSTABLE != 1 (got ${summary.NUMUNSTABLE})</li>\n"
                    stage_passed = false
                }

                if(summary.NUMABORTED == 1)
                {
                    email_body += "<li>PASSED: NUMABORTED == 1</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMABORTED != 1 (got ${summary.NUMABORTED})</li>\n"
                    stage_passed = false
                }

                if(summary.NUMNOT_BUILT == 1)
                {
                    email_body += "<li>PASSED: NUMNOT_BUILT == 1</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMNOT_BUILT != 1 (got ${summary.NUMNOT_BUILT})</li>\n"
                    stage_passed = false
                }
                email_body += "</ol>\n"
            }
            catch(ex)
            {
                println ">>> ERROR: parallelJobLauncher -- check last result summary failed"
                sendEmailFailure(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }

            /*
            if(!stage_passed)
            {
                sendEmailFailure(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }
            */

        }   // end stage 3



        // Create 2 vars to carry over to the email builder stage if stage 4 passes.
        def launcher_results = null
        def launcher_summary = null



        // Stage 4: Parallel Job Launcher (real-run mode jobs)
        stage("4) Test Parallel Job Launcher (real-run mode)")
        {
            boolean stage_passed = true

            def launcher = new gov.sandia.sems.spifi.ParallelJobLauncher(this)

            // Add one job of each type to the list
            exit_status_list.each
            {   _exit_status ->

                println ">>> LAUNCHER: APPEND(T-${_exit_status}-RUN)"

                launcher.appendJob(label: "T-${_exit_status}-RUN",
                                   job_name: "SPiFI_test_selectable_status",
                                   timeout: 90,
                                   timeout_unit: "SECONDS",
                                   parameters: [ (string(name:"EXIT_STATUS",  value: "${_exit_status}")),
                                                 (string(name:"SLEEP_TIME", value: "1"))
                                               ]
                                  )
            }

            // Add jobs that test expected_duration_min and expected_duration_max bounds
            // Both should have their status reset to UNSTABLE
            launcher.appendJob(label: "T-EXPECTED-DURATION-MIN-RUN",
                                job_name: "SPiFI_test_selectable_status",
                                timeout: 90,
                                timeout_unit: "SECONDS",
                                expected_duration_min: 1,
                                expected_duration_units: "MINUTES",
                                parameters: [ (string(name:"EXIT_STATUS", value: "SUCCESS")),
                                              (string(name:"SLEEP_TIME",  value: "12"))
                                            ]
                                )

            launcher.appendJob(label: "T-EXPECTED-DURATION-MAX-RUN",
                                job_name: "SPiFI_test_selectable_status",
                                timeout: 90,
                                timeout_unit: "SECONDS",
                                expected_duration_max: 8,
                                expected_duration_units: "SECONDS",
                                parameters: [ (string(name:"EXIT_STATUS", value: "SUCCESS")),
                                              (string(name:"SLEEP_TIME",  value: "12"))
                                            ]
                                )

            // This test should fail due to TIMEOUT
            launcher.appendJob(label: "T-TIMEOUT-TEST",
                                job_name: "SPiFI_test_selectable_status",
                                timeout: 5,
                                timeout_unit: "SECONDS",
                                parameters: [ (string(name:"EXIT_STATUS", value: "SUCCESS")),
                                              (string(name:"SLEEP_TIME",  value: "10"))
                                            ]
                                )


            // Print out the list of jobs.
            try
            {
                launcher.printJobList()
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                println ">>> ERROR: parallelJobLauncher -- printJobList failed"
                sendEmailFailure(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }

            // Launch the jobs in parallel
            try
            {
                launcher_results = launcher.launchInParallel()

                println(">>> results: ${launcher_results}")

                email_body += "<H3>Stage (4): Test Parallel Job Launcher (real-run mode)</H3>\n"

                email_body += "<ol>\n"
                exit_status_list.each
                {   _exit_status ->

                    String test_name = "T-${_exit_status}-RUN"

                    if(launcher_results["${test_name}"].status == "${_exit_status}")
                    {
                       email_body += "<li>PASSED: ${test_name}</li>\n"
                    }
                    else
                    {
                       stage_passed = false
                       email_body += "<li>FAILED: ${test_name}</li>\n"
                    }
                }
                email_body += "</ol>\n"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                println ">>> ERROR: parallelJobLauncher -- launchInParallel failed"
                sendEmailFailure(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }

            // Check result summary
            try
            {
                launcher_summary = launcher.getLastResultSummary()
                println ">>> SUMMARY: ${launcher_summary}"

                email_body += "<H4>Launcher Summary</H4>\n"
                email_body += "<ol>\n"
                if(launcher_summary.NUMJOBS == 8)
                {
                    email_body += "<li>PASSED: NUMJOBS == 8</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMJOBS != 8 (got ${launcher_summary.NUMJOBS})</li>\n"
                    stage_passed = false
                }

                if(launcher_summary.NUMSUCCESS == 1)
                {
                    email_body += "<li>PASSED: NUMSUCCESS == 1</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMSUCCESS != 1 (got ${launcher_summary.NUMSUCCESS})</li>\n"
                    stage_passed = false
                }

                if(launcher_summary.NUMFAILURE == 2)
                {
                    email_body += "<li>PASSED: NUMFAILURE == 2</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMFAILURE != 2 (got ${launcher_summary.NUMFAILURE})</li>\n"
                    stage_passed = false
                }

                if(launcher_summary.NUMUNSTABLE == 3)
                {
                    email_body += "<li>PASSED: NUMUNSTABLE == 3</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMUNSTABLE != 3 (got ${launcher_summary.NUMUNSTABLE})</li>\n"
                    stage_passed = false
                }

                if(launcher_summary.NUMABORTED == 1)
                {
                    email_body += "<li>PASSED: NUMABORTED == 1</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMABORTED != 1 (got ${launcher_summary.NUMABORTED})</li>\n"
                    stage_passed = false
                }

                if(launcher_summary.NUMNOT_BUILT == 1)
                {
                    email_body += "<li>PASSED: NUMNOT_BUILT == 1</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: NUMNOT_BUILT != 1 (got ${launcher_summary.NUMNOT_BUILT})</li>\n"
                    stage_passed = false
                }
                email_body += "</ol>\n"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                println ">>> ERROR: parallelJobLauncher -- check last result summary failed"
                sendEmailFailure(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }

        }   // End Stage 4


        // Stage 5: ResultsUtility
        stage("5) Test ResultsUtility")
        {
            boolean stage_passed = true

            println launcher_summary
            println launcher_results

            email_body += "<H3>Stage 5) Test Results Utility</H3>\n"

            email_body += "<ol>\n"

            def result_util = null
            try
            {   
                num_tests++
                result_util = new gov.sandia.sems.spifi.ResultsUtility(env: this)
                email_body += "<li>PASSED: Instantiate</li>\n"
            }
            catch(ex)
            {
                email_body += "<li>FAILED: Instantiate</li>\n"
                println ">>> ERROR:\n${ex}"
                num_failures++
            }

            // Test Summary Table Generation (ASCII)
            println ">>> Test Summary Table Generation (ASCII)"
            try{
                num_tests++
                def output = result_util.genResultSummaryTable(summary: launcher_summary, format: "ASCII")
                email_body += "<li>PASSED: genResultSummaryTable (ASCII)</li>\n"
                println ">>> summary table ascii:\n${output}"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<li>FAILED: genResultSummaryTable (ASCII)</li>\n"
                num_failures++
            }

            // Test Summary Table Generation (Markdown)
            println ">>> Test Summary Table Generation (MARKDOWN)"
            try{
                num_tests++
                def output = result_util.genResultSummaryTable(summary: launcher_summary, format: "MARKDOWN")
                email_body += "<li>PASSED: genResultSummaryTable (MARKDOWN)</li>\n"
                println ">>> summary table Markdown:\n${output}"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<li>FAILED: genResultSummaryTable (MARKDOWN)</li>\n"
                num_failures++
            }

            // Test Summary Table Generation (HTML)
            println ">>> Test Summary Table Generation (HTML)"
            try{
                num_tests++
                def output = result_util.genResultSummaryTable(summary: launcher_summary, format: "HTML")
                email_body += "<li>PASSED: genResultSummaryTable (HTML)</li>\n"
                println ">>> summary table HTML:\n${output}"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<li>FAILED: genResultSummaryTable (HTML)</li>\n"
                num_failures++
            }

            // Test Detail Table Generation (ASCII)
            println ">>> Test Detail Table Generation (ASCII)"
            try{
                num_tests++
                def output = result_util.genResultDetailTable(results: launcher_results, format: "ASCII")
                email_body += "<li>PASSED: genResultDetailTable (ASCII)</li>\n"
                println ">>> details table ascii:\n${output}"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<li>FAILED: genResultDetailTable (ASCII)</li>\n"
                num_failures++
            }



            // Test Detail Table Generation (MARKDOWN)
            println ">>> Test Detail Table Generation (MARKDOWN, link_to_console: default)"
            try{
                num_tests++
                def output = result_util.genResultDetailTable(results: launcher_results, format: "MARKDOWN")
                email_body += "<li>PASSED: genResultDetailTable (MARKDOWN, link_to_console: default)</li>\n"
                println ">>> details table ascii:\n${output}"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<li>FAILED: genResultDetailTable (MARKDOWN, link_to_console: default)</li>\n"
                num_failures++
            }

            println ">>> Test Detail Table Generation (MARKDOWN, link_to_console: false)"
            try{
                num_tests++
                def output = result_util.genResultDetailTable(results: launcher_results, 
                                                              format: "MARKDOWN",
                                                              link_to_console: false)
                email_body += "<li>PASSED: genResultDetailTable (MARKDOWN, link_to_console: false)</li>\n"
                println ">>> details table ascii:\n${output}"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<li>FAILED: genResultDetailTable (MARKDOWN, link_to_console: false)</li>\n"
                num_failures++
            }

            println ">>> Test Detail Table Generation (MARKDOWN, link_to_console: true)"
            try{
                num_tests++
                def output = result_util.genResultDetailTable(results: launcher_results, 
                                                              format: "MARKDOWN",
                                                              link_to_console: true)
                email_body += "<li>PASSED: genResultDetailTable (MARKDOWN, link_to_console: true)</li>\n"
                println ">>> details table ascii:\n${output}"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<li>FAILED: genResultDetailTable (MARKDOWN, link_to_console: true)</li>\n"
                num_failures++
            }




            // Test Detail Table Generation (HTML)
            println ">>> Test Detail Table Generation (HTML, link_to_console: default)"
            try{
                num_tests++
                def output = result_util.genResultDetailTable(results: launcher_results, format: "HTML")
                email_body += "<li>PASSED: genResultDetailTable (HTML, link_to_console: default)</li>\n"
                println ">>> details table ascii:\n${output}"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<li>FAILED: genResultDetailTable (HTML, link_to_console: default)</li>\n"
                num_failures++
            }

            println ">>> Test Detail Table Generation (HTML, link_to_console: false)"
            try{
                num_tests++
                def output = result_util.genResultDetailTable(results: launcher_results, 
                                                              format: "HTML",
                                                              link_to_console: false)
                email_body += "<li>PASSED: genResultDetailTable (HTML, link_to_console: false)</li>\n"
                println ">>> details table ascii:\n${output}"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<li>FAILED: genResultDetailTable (HTML, link_to_console: false)</li>\n"
                num_failures++
            }

            println ">>> Test Detail Table Generation (HTML, link_to_console: true)"
            try{
                num_tests++
                def output = result_util.genResultDetailTable(results: launcher_results, 
                                                              format: "HTML",
                                                              link_to_console: true)
                email_body += "<li>PASSED: genResultDetailTable (HTML, link_to_console: true)</li>\n"
                println ">>> details table ascii:\n${output}"
            }
            catch(ex)
            {
                println "ERROR:\n${ex}"
                email_body += "<li>FAILED: genResultDetailTable (HTML, link_to_console: true)</li>\n"
                num_failures++
            }



            email_body += "</ol>\n"
        }  // End Stage 5



        // Stage 6: Test org.sandia.sems.spifi.Shell
        stage("6) Shell")
        {
            boolean stage_passed = true

            email_body += "<H3>Stage (6): Test Shell</H3>\n"

            email_body += "<ol>\n"

            try
            {
                num_tests++
                def shell = new gov.sandia.sems.spifi.Shell()
                def output = shell.execute(env: this, command: "ls -l -tr", verbose: true)
                println "Shell Output:\n" +
                        "- retries: ${output.retries}\n" +
                        "- status : ${output.status}\n" +
                        "- stdout : ${output.stdout}\n"
                email_body += "<li>PASSED: Shell.execute()</li>\n"
            }
            catch(e)
            {
                num_failures++
                email_body += "<li>FAILED: Shell.execute() threw an exception</li>\n"
                println "ERROR occurred in Shell():\n${e}"
            }

            try
            {
                num_tests++
                def shell = new gov.sandia.sems.spifi.Shell()
                def output = shell.execute(env: this,
                                           command: "ls /aksfosuayfoausydfoy123123123",
                                           retries: 2,
                                           retry_delay: 2,
                                           verbose: true)
                println "Shell Output:\n" +
                        "- retries: ${output.retries}\n" +
                        "- status : ${output.status}\n"  +
                        "- stdout:\n${output.stdout}\n"
                if(output.status == 2 && output.retries == 2)
                {
                    email_body += "<li>PASSED: Shell.execute() nonzero status retry failure</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: Shell.execute() nonzero status retry failure</li>\n"
                    num_failures++
                }
            }
            catch(e)
            {
                num_failures++
                email_body += "<li>FAILED: Shell.execute() threw an exception</li>\n"
                println "ERROR occurred in Shell():\n${e}"
            }

            try
            {
                num_tests++
                def shell = new gov.sandia.sems.spifi.Shell()
                def output = shell.execute(env: this,
                                           command: "ls /aksfosuayfoausydfoy123123123",
                                           retries: 2,
                                           retry_delay: 2,
                                           status_values_ok: [2],
                                           verbose: true)
                println "Shell Output:\n" +
                        "- retries: ${output.retries}\n" +
                        "- status : ${output.status}\n"  +
                        "- stdout:\n${output.stdout}\n"
                if(output.status == 2 && output.retries==0)
                {
                    email_body += "<li>PASSED: Shell.execute() nonzero status whitelisted</li>\n"
                }
                else
                {
                    email_body += "<li>FAILED: Shell.execute() nonzero status whitelisted</li>\n"
                    num_failures++
                }
            }
            catch(e)
            {
                email_body += "<li>FAILED: Shell.execute() threw an exception</li>\n"
                println "ERROR occurred in Shell():\n${e}"
                num_failures++
            }

            email_body += "</ol>\n"

        } // End Stage 6



        // Stage 7: Test org.sandia.sems.spifi.Git
        stage("7) Git")
        {
            println "\u27A4\n" +
                    "\u27A4 Stage: Git\n" +
                    "\u27A4"
            boolean stage_passed = true

            email_body += "<H3>Stage (7): Test Git</H3>\n"
            email_body += "<ol>\n"
            try
            {
                num_tests++

                def git_spifi = new gov.sandia.sems.spifi.Git()

                git_spifi.clone(env: this,
                                dir: "SPiFI",
                                branch: branchName,
                                url: "git@gitlab-ex.sandia.gov:SEMS/sems-pipeline-framework-infrastructure.git",
                                credentialsId: "0aacc0f3-7e90-4b0f-9eda-068f1d6ce052",
                                retries: 2,
                                retry_delay: 10,
                                timeout: 90,
                                timeout_units: "SECONDS",
                                verbose: true
                               )

                def stdout = sh(script: "ls -ltr SPiFI/", returnStdout: true)
                println "STDOUT:\n${stdout}"
                email_body += "<li>PASSED: Git.clone() cloned a repository</li>\n"
            }
            catch(e)
            {
                email_body += "<li>FAILED: Git.clone() threw an exception</li>\n"
                println "ERROR: Git.clone() threw an exception:\n${e}"
                stage_passed = false
                num_failures++
                currentBuild.result='FAILURE'
                sendEmailFailure(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }

            email_body += "</ol>\n"

        } // End Stage 7


        // Stage 8: Test running a shell script that clones a repository that has the
        //          Jenkins entity account as a member.
        stage("8) Test Shell Script that Clones")
        {
            println "\u27A4\n" +
                    "\u27A4 Stage: Test Shell Script that Clones\n" +
                    "\u27A4"
            email_body += "<H3>Stage (8): Test Clone from Script</H3>\n"
            email_body += "<ol>\n"

            String repository_url = "git@gitlab-ex.sandia.gov:SEMS/sems-son-gitlab-test-repository.git"
            //String credentials_id = "80984bf0-0cb7-47ca-bf7a-892919ea7f34"
            //String repository_url = "git@gitlab.sandia.gov:SEMS/sems-snl-gitlab-test-repository.git"
            //String credentials_id = "0aacc0f3-7e90-4b0f-9eda-068f1d6ce052"

            try
            {
                num_tests++
                def shell = new gov.sandia.sems.spifi.Shell()

                def output = shell.execute(env: this,
                                           command: "SPiFI/tests/snlgitlab-clone-test.sh ${repository_url}",
                                           retries: 2,
                                           retry_delay: 10,
                                           timeout: 2,
                                           timeout_units: "MINUTES",
                                           verbose: true)

                println "Shell Output:\n" +
                        "- retries: ${output.retries}\n" +
                        "- status : ${output.status}\n" +
                        "- stdout : ${output.stdout}\n"

                if(0 == output.status)
                {
                    email_body += "<li>PASSED: Test Shell Script that clones a private repository.</li>\n"
                }
                else
                {
                    println "ERROR: nonzero exit status returned."
                    email_body += "<li>FAILED: Test Shell Script that clones a private repository.\n"
                    email_body += "</li>\n"
                    currentBuild.result='FAILURE'
                    num_failures++
                }
            }
            catch(e)
            {
                num_failures++
                currentBuild.result='FAILURE'
                email_body += "<li>FAILED: Shell.execute() threw an exception</li>\n"
                println "ERROR: occurred in Shell():\n${e}"
            }
            email_body += "</ol>\n"
        }

        // Stage 9: Test HTMLUtility
        stage("9) Test HTMLUtility")
        {
            println "\u27A4\n" +
                    "\u27A4 Stage: Test HTMLUtility\n" +
                    "\u27A4"
            email_body += "<H3>Stage (9): Test HTMLUtility</H3>\n"                    

            def htmlutil = new gov.sandia.sems.spifi.HTMLUtility(env: this)

            // Test generating an ordered list.
            List email_data = []
            try 
            {
                num_tests++
                email_data.add("PASSED: HTMLUtility: Generate Ordered List")
                email_body += htmlutil.generateList(data: email_data)
            } 
            catch(ex)
            {
                email_body += "<OL>\n"
                email_body += "    <LI>FAILED: HTMLUtility: Generate Ordered List</LI>\n"
                email_body += "</OL>\n"
                currentBuild.result='FAILURE'
                num_failures++
                println "ERROR:\n${ex}\n"
            }

            // Test generating an unordered list
            email_data = []
            try 
            {
                num_tests++
                email_data = []
                email_data.add("PASSED: HTMLUtility: Generate Unordered List")
                email_body += htmlutil.generateList(data: email_data, unordered_list: true)
            } 
            catch(ex)
            {
                email_body += "<OL>\n"
                email_body += "    <LI>FAILED: HTMLUtility: Generate Unordered List</LI>\n"
                email_body += "</OL>\n"
                currentBuild.result='FAILURE'
                num_failures++
                println "ERROR:\n${ex}\n"
            }
        }


        stage("10) Cleanup")
        {
            println "\u27A4\n" +
                    "\u27A4 Stage: Cleanup\n" +
                    "\u27A4"
            if(fileExists("SPiFI"))
            {
                dir("SPiFI")
                {
                    deleteDir()
                }
            }
        }


        // Stage 11: Summary (is that even necessary?)
        stage("11) Email Summary")
        {
            println "\u27A4\n" +
                    "\u27A4 Stage: Summary\n" +
                    "\u27A4"

            // Final test is to try and send email using SPiFI EmailMessage class
            // if it fails then send the usual email.
            try
            {
                num_tests++
                String status = "SUCCESS"
                if(0 != num_failures)
                {
                    status = "FAILURE"
                    currentBuild.result = "FAILURE"
                }
                
                String email_body_summary = ""
                email_body_summary += "<H1>Testing Summary</H1>\n" +
                                      "<H3>Overview</H3>\n" +
                                      "<ol>\n" +
                                      "  <li>Final Status: ${status}</li>\n" +
                                      "  <li>Num Tests   : ${num_tests}</li>\n" +
                                      "  <li>Num Failures: ${num_failures}</li>\n" +
                                      "  <li>Job node    : ${NODE_NAME}</li>\n" +
                                      "</ol>\n"
                email_body = email_body_summary + email_body

                email_body += "<P>--<BR/>View output on <A HREF=\"${BUILD_URL}\">Jenkins</A>.</P>"

                mail to:       emailDevOps,
                     replyTo:  emailReplyTo,
                     mimeType: "text/html",
                     subject:  "[SPiFI] Testing Summary ${status} for ${branchName} on ${jenkins_site}",
                     body:     email_body
            }
            catch(e)
            {
                num_failures++
                println ">>> ERROR:${e}"
                email_body += "<H3>Stage (9): Email Summary</H3>\n"
                sendEmailFailure(to: emailDevOps, reply_to: emailReplyTo, body: email_body)
                return
            }
        }   // End Stage 11

    }   // timeout
}   // node



def sendEmailFailure(Map params)
{
    String email_body_summary = ""
    email_body_summary += "<H1>Testing Summary</H1>\n" +
                          "<H3>Overview</H3>\n" +
                          "<ol>\n" +
                          "  <li>Final Status: FAILURE</li>\n" +
                          "  <li>Num Tests   : ${num_tests}</li>\n" +
                          "  <li>Num Failures: ${num_failures}</li>\n" +
                          "  <li>Job node    : ${NODE_NAME}</li>\n" +
                          "</ol>\n"

    email_body = email_body_summary + params.body

    sendEmailSummary(to:       params.to,
                     reply_to: params.reply_to,
                     subject:  "[SPiFI] Testing Summary FAILED",
                     body:     email_body)
    currentBuild.result='FAILURE'
}



def sendEmailSummary(Map params)
{
    String email_message = """
                           <HTML>
                           <HEAD>
                           </HEAD>
                           <BODY>
                           {{MESSAGE_BODY}}
                           </BODY>
                           </HTML>
                           """.stripIndent()

    String __email_message = email_message.replace("{{MESSAGE_BODY}}", params.body)

    mail to:       params.to,
         replyTo:  params.reply_to,
         mimeType: 'text/html',
         subject:  params.subject,
         body:     __email_message
    }

