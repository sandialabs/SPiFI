#!/usr/bin/env groovy

@Library('SPiFI-DEV@experimental') _

properties([
    disableConcurrentBuilds(),
    buildDiscarder(logRotator(artifactDaysToKeepStr: '',
                              artifactNumToKeepStr: '',
                              daysToKeepStr: '365',
                              numToKeepStr: '90'))
])

node("rhel7")
{
    timestamps()
    {

        try
        {
        }
        catch(ex)
        {
        }

        stage("Clean Workspace")
        {
            cleanWs()
        }

        /*
        stage("Test Timeout")
        {
            try {
            timeout(time: 5, unit: "SECONDS")
            {
                sleep 10
            }
            } catch(ex) {
                println ">>> Timeout exception happened, ${ex}"
            }
        }
        */
        /*
        stage("Test SPiFI::Shell()")
        {
            // sh(script: 'ls -l -t -r -a')
            shell = new gov.sandia.sems.spifi.Shell()
            def output = shell.execute(env: this,
                                       command: "ls -l -t -r",
                                       path: "foo")

            println output
            println "output.status: ${output.status}"
            println "output.stdout:\n${output.stdout}\n"
        }
        */

        stage("Retry-Test-1")
        {
            def launcher = new gov.sandia.sems.spifi.ParallelJobLauncher("env": this)
            // def launcher = new gov.sandia.sems.spifi.ParallelJobLauncher(this)


            println ">>> -------------------------"
            def retry = new gov.sandia.sems.spifi.DelayedRetryOnRegex("env": this, "retry_regex": "My Retry Condition")
            println ">>> retry                   = ${retry}\n" +
                    ">>> retry                   = ${retry.asString()}\n" +
                    ">>> retry.retry_delay       = ${retry.retry_delay}\n" +
                    ">>> retry.retry_delay_units = ${retry.retry_delay_units}\n" +
                    ">>> retry.retry_regex       = ${retry.retry_regex}"
            println ">>> -------------------------"


            launcher.appendJob(label: "T-1",
                               job_name: "SPiFI_test_pass_every_third",
                               timeout: 6,
                               timeout_unit: "MINUTES",
                               parameters: [ (string(name:"NODE_RESTRICTION", value: "RHEL7 || RHEL6 || master || coeus")),
                                             (string(name:"PARAM_THRESHOLD",  value: "4"))
                                           ],
                               dry_run: false,
                               /* NEW */ retry_max_count: 5,
                               /* NEW */ retry_conditions: [
                                                    new gov.sandia.sems.spifi.DelayedRetryOnRegex("env": this,
                                                                                                  "retry_delay": 1,
                                                                                                  "retry_delay_units": "MINUTES",
                                                                                                  "retry_regex": "TestingError_UNSTABLE"),
                                                    new gov.sandia.sems.spifi.DelayedRetryOnRegex("env": this,
                                                                                                  "retry_delay": 10,
                                                                                                  "retry_delay_units": "SECONDS",
                                                                                                  "retry_regex": "TestingError_FAILURE")
                                                 ]
                              )

            launcher.printJobList()

            def results = launcher.launchInParallel()

            println ">>> Results:\n${results}"

            def summary = launcher.getLastResultSummary()

            def result_util = new gov.sandia.sems.spifi.ResultsUtility(env: this)
            def output = result_util.genResultSummaryTable(summary: summary, format: "ASCII")
            println ">>> summary table:\n${output}"
        }



        // TODO: Decide if the 'test' should be a single big pipeline job that
        //       exercises the capabilities of SPiFI or if it's just a pipeline job
        //       that launches sub-jobs which test smaller things...

    }
}



